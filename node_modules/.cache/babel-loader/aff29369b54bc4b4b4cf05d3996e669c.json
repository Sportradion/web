{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/carlleandersson/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/carlleandersson/web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar decodeIco = require('decode-ico');\n\nvar _require = require('../mime'),\n    MIME_PNG = _require.MIME_PNG;\n/**\n * @typedef {object} ParsedImage\n * @property {number} width Image width.\n * @property {number} height Image height.\n * @property {number} bpp Image color depth as bits per pixel.\n * @property {ArrayBuffer} buffer Image buffer.\n */\n\n/**\n * Parse ICO and return some image object.\n *\n * @access private\n * @param {ArrayBuffer|Buffer} data - ICO file data.\n * @param {string} mime - MIME type for output.\n * @param {object} Image - Image encoder/decoder.\n * @returns {Promise<ParsedImage[]>} Resolves to an array of {@link ParsedImage}.\n */\n\n\nvar parse = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data, mime, Image) {\n    var icons, transcodeImage, parsedImages;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            icons = decodeIco(data);\n\n            transcodeImage = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(icon) {\n                var decoded;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!(mime === MIME_PNG && icon.type === 'png')) {\n                          _context.next = 2;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\", Object.assign({\n                          buffer: icon.data.buffer.slice(icon.data.byteOffset, icon.data.byteOffset + icon.data.byteLength)\n                        }, icon));\n\n                      case 2:\n                        if (!(icon.type === 'png')) {\n                          _context.next = 7;\n                          break;\n                        }\n\n                        _context.next = 5;\n                        return Image.decode(icon.data);\n\n                      case 5:\n                        decoded = _context.sent;\n                        Object.assign(icon, {\n                          data: decoded.data,\n                          type: 'bmp'\n                        });\n\n                      case 7:\n                        _context.t0 = Object;\n                        _context.t1 = icon;\n                        _context.next = 11;\n                        return Image.encode(icon, mime);\n\n                      case 11:\n                        _context.t2 = _context.sent;\n                        _context.t3 = mime.replace('image/', '');\n                        _context.t4 = {\n                          buffer: _context.t2,\n                          type: _context.t3\n                        };\n                        return _context.abrupt(\"return\", _context.t0.assign.call(_context.t0, _context.t1, _context.t4));\n\n                      case 15:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function transcodeImage(_x4) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            _context2.next = 4;\n            return Promise.all(icons.map(transcodeImage));\n\n          case 4:\n            parsedImages = _context2.sent;\n            return _context2.abrupt(\"return\", parsedImages);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function parse(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/carlleandersson/web/node_modules/icojs/src/parse/index.js"],"names":["decodeIco","require","MIME_PNG","parse","data","mime","Image","icons","transcodeImage","icon","type","Object","assign","buffer","slice","byteOffset","byteLength","decode","decoded","encode","replace","Promise","all","map","parsedImages","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,YAAD,CAAzB;;eACqBA,OAAO,CAAC,SAAD,C;IAApBC,Q,YAAAA,Q;AAER;;;;;;;;AAQA;;;;;;;;;;;AASA,IAAMC,KAAK;AAAA,sEAAG,kBAAOC,IAAP,EAAaC,IAAb,EAAmBC,KAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AACNC,YAAAA,KADM,GACEP,SAAS,CAACI,IAAD,CADX;;AAGNI,YAAAA,cAHM;AAAA,mFAGW,iBAAMC,IAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BACjBJ,IAAI,KAAKH,QAAT,IAAqBO,IAAI,CAACC,IAAL,KAAc,KADlB;AAAA;AAAA;AAAA;;AAAA,yDAEZC,MAAM,CAACC,MAAP,CAAc;AAAEC,0BAAAA,MAAM,EAAEJ,IAAI,CAACL,IAAL,CAAUS,MAAV,CAAiBC,KAAjB,CAAuBL,IAAI,CAACL,IAAL,CAAUW,UAAjC,EAA6CN,IAAI,CAACL,IAAL,CAAUW,UAAV,GAAuBN,IAAI,CAACL,IAAL,CAAUY,UAA9E;AAAV,yBAAd,EAAqHP,IAArH,CAFY;;AAAA;AAAA,8BAKjBA,IAAI,CAACC,IAAL,KAAc,KALG;AAAA;AAAA;AAAA;;AAAA;AAAA,+BAMGJ,KAAK,CAACW,MAAN,CAAaR,IAAI,CAACL,IAAlB,CANH;;AAAA;AAMbc,wBAAAA,OANa;AAOnBP,wBAAAA,MAAM,CAACC,MAAP,CAAcH,IAAd,EAAoB;AAClBL,0BAAAA,IAAI,EAAEc,OAAO,CAACd,IADI;AAElBM,0BAAAA,IAAI,EAAE;AAFY,yBAApB;;AAPmB;AAAA,sCAadC,MAbc;AAAA,sCAaAF,IAbA;AAAA;AAAA,+BAcLH,KAAK,CAACa,MAAN,CAAaV,IAAb,EAAmBJ,IAAnB,CAdK;;AAAA;AAAA;AAAA,sCAebA,IAAI,CAACe,OAAL,CAAa,QAAb,EAAuB,EAAvB,CAfa;AAAA;AAcnBP,0BAAAA,MAdmB;AAenBH,0BAAAA,IAfmB;AAAA;AAAA,qEAaPE,MAbO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAHX;;AAAA,8BAGNJ,cAHM;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAsBea,OAAO,CAACC,GAAR,CAAYf,KAAK,CAACgB,GAAN,CAAUf,cAAV,CAAZ,CAtBf;;AAAA;AAsBNgB,YAAAA,YAtBM;AAAA,8CAuBLA,YAvBK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAALrB,KAAK;AAAA;AAAA;AAAA,GAAX;;AA0BAsB,MAAM,CAACC,OAAP,GAAiBvB,KAAjB","sourcesContent":["'use strict';\n\nconst decodeIco = require('decode-ico');\nconst { MIME_PNG } = require('../mime');\n\n/**\n * @typedef {object} ParsedImage\n * @property {number} width Image width.\n * @property {number} height Image height.\n * @property {number} bpp Image color depth as bits per pixel.\n * @property {ArrayBuffer} buffer Image buffer.\n */\n\n/**\n * Parse ICO and return some image object.\n *\n * @access private\n * @param {ArrayBuffer|Buffer} data - ICO file data.\n * @param {string} mime - MIME type for output.\n * @param {object} Image - Image encoder/decoder.\n * @returns {Promise<ParsedImage[]>} Resolves to an array of {@link ParsedImage}.\n */\nconst parse = async (data, mime, Image) => {\n  const icons = decodeIco(data);\n\n  const transcodeImage = async icon => {\n    if (mime === MIME_PNG && icon.type === 'png') {\n      return Object.assign({ buffer: icon.data.buffer.slice(icon.data.byteOffset, icon.data.byteOffset + icon.data.byteLength) }, icon);\n    }\n\n    if (icon.type === 'png') {\n      const decoded = await Image.decode(icon.data);\n      Object.assign(icon, {\n        data: decoded.data,\n        type: 'bmp'\n      });\n    }\n\n    return Object.assign(icon, {\n      buffer: await Image.encode(icon, mime),\n      type: mime.replace('image/', '')\n    });\n  };\n\n  const parsedImages = await Promise.all(icons.map(transcodeImage));\n  return parsedImages;\n};\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}